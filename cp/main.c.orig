/*
 * Copyright (c) 2017 Intel Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <arpa/inet.h>
#include <errno.h>
#include <limits.h>
#include <stdlib.h>
#include <getopt.h>
#include <assert.h>
#include <string.h>
#include <unistd.h>
#include <time.h>
#include <ctype.h>
#include <pcap.h>

#include <rte_memory.h>
#include <rte_memzone.h>
#include <rte_launch.h>
#include <rte_eal.h>
#include <rte_per_lcore.h>
#include <rte_lcore.h>
#include <rte_debug.h>
#include <rte_errno.h>
#include <rte_ip.h>
#include <rte_udp.h>
#include <rte_ether.h>

#include <rte_common.h>
#include <rte_acl.h>
#include <rte_ip.h>

#include "gtpv2c.h"
#include "gtpv2c_ie.h"
#include "debug_str.h"
#include "ue.h"
#include "interface.h"
#include "packet_filters.h"

#define PCAP_TTL                     (64)
#define PCAP_VIHL                    (0x0045)

#define S11_SGW_IP_SET               (0x01)
#define S11_MME_IP_SET               (0x02)
#define S1U_SGW_IP_SET               (0x04)
#define IP_POOL_IP_SET               (0x08)
#define IP_POOL_MASK_SET             (0x10)
#define APN_NAME_SET                 (0x20)
#define REQ_ARGS                     (S11_SGW_IP_SET | S11_MME_IP_SET | \
					S1U_SGW_IP_SET | IP_POOL_IP_SET | \
					IP_POOL_MASK_SET | APN_NAME_SET)

pcap_dumper_t *pcap_dumper;
pcap_t *pcap_reader;
char errbuff[PCAP_ERRBUF_SIZE];

/**
 * Parses c-string containing dotted decimal ipv4 and stores the
 *   value within the in_addr type
 *
 * @param optarg
 *   c-string containing dotted decimal ipv4 address
 * @param addr
 *   destination of parsed IP string
 */
static void
parse_arg_ip(const char *optarg, struct in_addr *addr)
{
	if (!inet_aton(optarg, addr))
		rte_panic("Invalid argument - %s - Exiting.\n", optarg);
}

/**
 *
 * Parses non-dpdk command line program arguments for control plane
 *
 * @param argc
 *   number of arguments
 * @param argv
 *   array of c-string arguments
 */
static void
parse_arg(int argc, char **argv)
{
	int args_set = 0;
	int c = 0;

	const struct option long_options[] = {
	  {"s11_sgw_ip",  required_argument, NULL, 's'},
	  {"s11_mme_ip",  required_argument, NULL, 'm'},
	  {"s1u_sgw_ip",  required_argument, NULL, 'w'},
	  {"ip_pool_ip",  required_argument, NULL, 'i'},
	  {"ip_pool_mask", required_argument, NULL, 'p'},
	  {"apn_name",   required_argument, NULL, 'a'},
	  {"pcap_file_in", required_argument, NULL, 'x'},
	  {"pcap_file_out", required_argument, NULL, 'y'},
	  {0, 0, 0, 0}
	};

	do {
		int option_index = 0;

		c = getopt_long(argc, argv, "s:m:w:i:p:a:x:y:", long_options,
		    &option_index);

		if (c == -1)
			break;

		switch (c) {
		case 's':
			parse_arg_ip(optarg, &s11_sgw_ip);
			args_set |= S11_SGW_IP_SET;
			break;
		case 'm':
			parse_arg_ip(optarg, &s11_mme_ip);
			args_set |= S11_MME_IP_SET;
			break;
		case 'i':
			set_ip_pool_ip(optarg);
			args_set |= S1U_SGW_IP_SET;
			break;
		case 'p':
			set_ip_pool_mask(optarg);
			args_set |= IP_POOL_IP_SET;
			break;
		case 'w':
			parse_arg_ip(optarg, &s1u_sgw_ip);
			args_set |= IP_POOL_MASK_SET;
			break;
		case 'a':
			set_apn_name(&one_apn, optarg);
			args_set |= APN_NAME_SET;
			break;
		case 'x':
			pcap_reader = pcap_open_offline(optarg, errbuff);
			break;
		case 'y':
			pcap_dumper = pcap_dump_open(
				pcap_open_dead(DLT_EN10MB, UINT16_MAX), optarg);
			break;
		default:
			rte_panic("Unknown argument - %s.", argv[optind]);
			break;
		}
	} while (c != -1);
	if ((args_set & REQ_ARGS) != REQ_ARGS) {
		fprintf(stderr, "Usage: %s\n", argv[0]);
		for (c = 0; long_options[c].name; ++c) {
			fprintf(stderr, "\t[ -%s | -%c ] %s\n",
					long_options[c].name,
					long_options[c].val,
					long_options[c].name);
		}
		rte_panic("\n");
	}
}

uint64_t create_session_counter;
uint64_t delete_session_counter;
uint64_t modify_bearer_counter;
uint64_t bearer_resource_cmd_counter;
uint64_t create_bearer_counter;
uint64_t delete_bearer_counter;
uint64_t echo_counter;

uint64_t rx_counter;
uint64_t tx_counter;
uint64_t rx_counter_last;
uint64_t tx_counter_last;

/**
 * Prints control plane signaling message statistics
 *
 * @return
 *   Never returns/value ignored
 */
static int
do_stats(__rte_unused void *ptr)
{
	uint32_t lines = 0;

	while (1) {
		if (!(lines % 32)) {
			printf("\n%5s %8s %8s %8s %8s %8s %8s"
					"%8s %8s %8s %8s %8s\n",
				"", "rx", "tx", "rx pkts", "tx pkts",
				"create", "modify", "b resrc", "create",
				"delete", "delete", "");
			printf("%5s %8s %8s %8s %8s %8s %8s"
					"%8s %8s %8s %8s %8s\n",
				"time", "pkts", "pkts", "/sec", "/sec",
				"session", "bearer", "command",
				"bearer", "bearer", "session", "echo");
		}

		printf("%5"PRIu32" %8lu %8lu %8lu %8lu %8lu %8lu"
			"%8lu %8lu %8lu %8lu %8lu\n",
			lines, rx_counter, tx_counter,
			rx_counter - rx_counter_last,
			tx_counter - tx_counter_last, create_session_counter,
			modify_bearer_counter, bearer_resource_cmd_counter,
			create_bearer_counter, delete_bearer_counter,
			delete_session_counter, echo_counter);

		rx_counter_last = rx_counter;
		tx_counter_last = tx_counter;

		++lines;

		sleep(1);
	}
	return 0;
}

/**
 * @brief
 * Initializes Control Plane data structures, packet filters, and calls for the
 * Data Plane to create required tables
 */
static void
init_cp(void)
{
	struct dp_id dp_id = { .id = DPN_ID };
	iface_module_constructor(CP);

	sprintf(dp_id.name, SDF_FILTER_TABLE);
	if (sdf_filter_table_create(dp_id, SDF_FILTER_TABLE_SIZE))
		rte_panic("sdf_filter_table creation failed\n");

	sprintf(dp_id.name, ADC_TABLE);
	if (adc_table_create(dp_id, ADC_TABLE_SIZE))
		rte_panic("adc_table creation failed\n");

	sprintf(dp_id.name, PCC_TABLE);
	if (pcc_table_create(dp_id, PCC_TABLE_SIZE))
		rte_panic("pcc_table creation failed\n");

	sprintf(dp_id.name, METER_PROFILE_SDF_TABLE);
	if (meter_profile_table_create(dp_id, METER_PROFILE_SDF_TABLE_SIZE))
		rte_panic("meter_profile_sdf_table creation failed\n");

	sprintf(dp_id.name, SESSION_TABLE);

	if (session_table_create(dp_id, LDB_ENTRIES_DEFAULT))
		rte_panic("session_table creation failed\n");

	init_packet_filters();
	parse_adc_rules();
	create_ue_hash();
}


/**
 * Central working function of the control plane. Reads message from s11/pcap,
 * calls appropriate function to handle message, writes response
 * message (if any) to s11/pcap
 *
 * @param arg
 *   unused
 * @return
 *   Always returns 0 if reading from pcap, otherwise never returns
 */
static int
lcore_control_plane(__rte_unused void *arg)
{
	int ret;
	uint8_t rx_buf[MAX_GTPV2C_UDP_LEN] = { 0 };
	uint8_t tx_buf[MAX_GTPV2C_UDP_LEN] = { 0 };
	gtpv2c_header *gtpv2c_rx = (gtpv2c_header *) rx_buf;
	gtpv2c_header *gtpv2c_tx = (gtpv2c_header *) tx_buf;

	int socket_fd = socket(AF_INET, SOCK_DGRAM, 0);
	uint16_t payload_length;
	const in_port_t s11_port = htons(GTPC_UDP_PORT);
	struct sockaddr_in peer = { .sin_port = 0};
	socklen_t peer_len = sizeof(peer);
	struct sockaddr_in sgw_s11_sockaddr_in;
	struct sockaddr_in mme_s11_sockaddr_in;
	uint32_t bytes_rx, bytes_tx;
	if (socket_fd < 0)
		rte_panic("Socket call error : %s", strerror(errno));

	bzero(sgw_s11_sockaddr_in.sin_zero,
			sizeof(sgw_s11_sockaddr_in.sin_zero));
	sgw_s11_sockaddr_in.sin_family = AF_INET;
	sgw_s11_sockaddr_in.sin_port = s11_port;
	sgw_s11_sockaddr_in.sin_addr = s11_sgw_ip;

	bzero(mme_s11_sockaddr_in.sin_zero,
			sizeof(mme_s11_sockaddr_in.sin_zero));
	mme_s11_sockaddr_in.sin_family = AF_INET;
	mme_s11_sockaddr_in.sin_port = s11_port;
	mme_s11_sockaddr_in.sin_addr = s11_mme_ip;

	errno = 0;

	if (!pcap_reader && !pcap_reader) {
		if (bind(socket_fd, (struct sockaddr *) &sgw_s11_sockaddr_in,
		    sizeof(sgw_s11_sockaddr_in)) < 0) {
			rte_panic("Bind error for %s:%u - %s\n",
			    inet_ntoa(sgw_s11_sockaddr_in.sin_addr),
			    ntohs(sgw_s11_sockaddr_in.sin_port),
			    strerror(errno));
		}
	}

	while (1) {

		if (pcap_reader) {
			static struct pcap_pkthdr *pcap_rx_header;
			const u_char *t;
			const u_char **tmp = &t;
			ret = pcap_next_ex(pcap_reader, &pcap_rx_header, tmp);
			if (ret < 0) {
				printf("Finished reading from pcap file"
						" - exiting\n");
				exit(0);
			}
			bytes_rx = pcap_rx_header->caplen
					- (sizeof(struct ether_hdr)
					+ sizeof(struct ipv4_hdr)
					+ sizeof(struct udp_hdr));
			memcpy(gtpv2c_rx, *tmp
					+ (sizeof(struct ether_hdr)
					+ sizeof(struct ipv4_hdr)
					+ sizeof(struct udp_hdr)), bytes_rx);

		} else {
			bytes_rx = recvfrom(socket_fd, rx_buf,
					MAX_GTPV2C_UDP_LEN, 0,
					(struct sockaddr *) &peer, &peer_len);
		}

		if (bytes_rx == 0) {
			fprintf(stderr, "recvfrom error for %s:%u - %s\n",
			    inet_ntoa(peer.sin_addr), peer.sin_port,
			    strerror(errno));
			continue;
		} else if (bytes_rx
		    != (ntohs(gtpv2c_rx->gtpc.length)
				    + sizeof(gtpv2c_rx->gtpc))) {
			ret = GTPV2C_CAUSE_INVALID_LENGTH;
			/* According to 29.274 7.7.7, if message is request,
			 * reply with cause = GTPV2C_CAUSE_INVALID_LENGTH
			 *  should be sent - ignoring packet for now
			 */
			fprintf(stderr,
			    "Recieved UDP Payload (%d bytes) with gtpv2c + "
					"header (%u + %lu) = %lu bytes\n",
			    bytes_rx, ntohs(gtpv2c_rx->gtpc.length),
			    sizeof(gtpv2c_rx->gtpc),
			    ntohs(gtpv2c_rx->gtpc.length)
			    + sizeof(gtpv2c_rx->gtpc));
			continue;
		}

		++rx_counter;

		if (!pcap_reader
		    && (peer.sin_addr.s_addr != s11_mme_ip.s_addr
			    || gtpv2c_rx->gtpc.version != GTP_VERSION_GTPV2C)) {
			fprintf(stderr,
			    "Discarding packet from %s:%u - "
					"Expected S11_MME_IP = %s\n",
			    inet_ntoa(peer.sin_addr), ntohs(peer.sin_port),
			    inet_ntoa(s11_mme_ip));
			continue;
		}

		switch (gtpv2c_rx->gtpc.type) {
		case GTP_CREATE_SESSION_REQ:
			ret = process_create_session_request(
					gtpv2c_rx, gtpv2c_tx);
			break;
		case GTP_DELETE_SESSION_REQ:
			ret = process_delete_session_request(
					gtpv2c_rx, gtpv2c_tx);
			break;
		case GTP_MODIFY_BEARER_REQ:
			ret = process_modify_bearer_request(
					gtpv2c_rx, gtpv2c_tx);
			break;
		case GTP_BEARER_RESOURCE_CMD:
			ret = process_bearer_resource_command(
					gtpv2c_rx, gtpv2c_tx);
			break;
		case GTP_ECHO_REQ:
			ret = process_echo_request(gtpv2c_rx, gtpv2c_tx);
			break;
		case GTP_CREATE_BEARER_RSP:
			ret = process_create_bearer_response(gtpv2c_rx);
			break;
		case GTP_DELETE_BEARER_RSP:
			ret = process_delete_bearer_response(gtpv2c_rx);
			break;
		default:
			fprintf(stderr,
			    "Received unprocessed GTPv2c Message Type: "
			    "%s (%u 0x%x)... Discarding\n",
			    gtp_type_str(gtpv2c_rx->gtpc.type),
				    gtpv2c_rx->gtpc.type,
				    gtpv2c_rx->gtpc.type);
			continue;
			break;
		}

		if (ret) {
			fprintf(stderr, "Error on message %s: (%d) %s\n",
			    gtp_type_str(gtpv2c_rx->gtpc.type), ret,
			    (ret < 0 ? strerror(-ret) : cause_str(ret)));
			/* S11 error handling not implemented */
			continue;
		}

		switch (gtpv2c_rx->gtpc.type) {
		case GTP_CREATE_BEARER_RSP:
			create_bearer_counter++;
			continue;
			break;
		case GTP_DELETE_BEARER_RSP:
			delete_bearer_counter++;
			continue;
			break;
		}

		payload_length = ntohs(gtpv2c_tx->gtpc.length)
				+ sizeof(gtpv2c_tx->gtpc);

		if (pcap_dumper) {
			static struct pcap_pkthdr pcap_tx_header;
			gettimeofday(&pcap_tx_header.ts, NULL);
			pcap_tx_header.caplen = payload_length
					+ sizeof(struct ether_hdr)
					+ sizeof(struct ipv4_hdr)
					+ sizeof(struct udp_hdr);
			pcap_tx_header.len = payload_length
					+ sizeof(struct ether_hdr)
					+ sizeof(struct ipv4_hdr)
					+ sizeof(struct udp_hdr);
			uint8_t dump_buf[MAX_GTPV2C_UDP_LEN
					+ sizeof(struct ether_hdr)
					+ sizeof(struct ipv4_hdr)
					+ sizeof(struct udp_hdr)];
			struct ether_hdr *eh = (struct ether_hdr *) dump_buf;

			memset(&eh->d_addr, '\0', sizeof(struct ether_addr));
			memset(&eh->s_addr, '\0', sizeof(struct ether_addr));
			eh->ether_type = htons(ETHER_TYPE_IPv4);

			struct ipv4_hdr *ih = (struct ipv4_hdr *) &eh[1];

			ih->dst_addr = s11_mme_ip.s_addr;
			ih->src_addr = s11_sgw_ip.s_addr;
			ih->next_proto_id = IPPROTO_UDP;
			ih->version_ihl = PCAP_VIHL;
			ih->total_length =
					ntohs(payload_length
						+ sizeof(struct udp_hdr)
						+ sizeof(struct ipv4_hdr));
			ih->time_to_live = PCAP_TTL;

			struct udp_hdr *uh = (struct udp_hdr *) &ih[1];

			uh->dgram_len = htons(
			    ntohs(ih->total_length) - sizeof(struct ipv4_hdr));
			uh->dst_port = htons(GTPC_UDP_PORT);
			uh->src_port = htons(GTPC_UDP_PORT);

			void *payload = &uh[1];
			memcpy(payload, tx_buf, payload_length);
			pcap_dump((u_char *) pcap_dumper, &pcap_tx_header,
					dump_buf);
			fflush(pcap_dump_file(pcap_dumper));
		} else {
			bytes_tx = sendto(socket_fd, tx_buf, payload_length, 0,
				(struct sockaddr *) &peer, peer_len);

			if (bytes_tx != (int) payload_length) {
				fprintf(stderr,
				    "Transmitted Incomplete GTPv2c Message:"
						"%u of %d tx bytes\n",
				    payload_length, bytes_tx);
			}
		}

		++tx_counter;

		switch (gtpv2c_rx->gtpc.type) {
		case GTP_CREATE_SESSION_REQ:
			create_session_counter++;
			break;
		case GTP_DELETE_SESSION_REQ:
			delete_session_counter++;
			break;
		case GTP_MODIFY_BEARER_REQ:
			modify_bearer_counter++;
			break;
		case GTP_ECHO_REQ:
			echo_counter++;
			break;
		case GTP_BEARER_RESOURCE_CMD:
			bearer_resource_cmd_counter++;
			break;
		}

		bzero(&tx_buf, sizeof(tx_buf));
	}
	return 0;
}

/**
 * Main function - initializes dpdk environment, parses command line arguments,
 * calls initialization function, and spawns stats and control plane function
 * @param argc
 *   number of arguments
 * @param argv
 *   array of c-string arguments
 * @return
 *   returns 0
 */
int main(int argc, char **argv)
{
	int ret;
	unsigned stats_core_id;
	ret = rte_eal_init(argc, argv);
	if (ret < 0)
		rte_panic("Cannot init EAL\n");

	parse_arg(argc - ret, argv + ret);
	printf("s11_sgw_ip:  %s\n", inet_ntoa(s11_sgw_ip));
	printf("s11_mme_ip:  %s\n", inet_ntoa(s11_mme_ip));
	printf("s1u_sgw_ip:  %s\n", inet_ntoa(s1u_sgw_ip));

	init_cp();

	stats_core_id = rte_get_next_lcore(rte_get_master_lcore(), 1, 1);
	if (stats_core_id != RTE_MAX_LCORE)
		rte_eal_remote_launch(do_stats, NULL, stats_core_id);
	else
		fprintf(stderr, "Insufficient cores in coremask to "
				"spawn stats thread\n");

	lcore_control_plane(NULL);

	rte_eal_mp_wait_lcore();

	return 0;
}
